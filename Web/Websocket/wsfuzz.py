import websocket
import ssl 
import json
import argparse
import _thread as thread
import time

key = ""
wordlist = ""
successfulCmds = []
lines = ""

#event handler for when the connection is opened 
def on_open(ws):
    def run():
        print(wordlist)
        file = open(wordlist, 'r')
        lines = file.readlines()
        curLineNumber = 0
        for line in lines:
            print("(*) Testing cmd: " + line.strip())
            ws.send(toJson("command", line.strip(), counter))
            curLineNumber=curLineNumber+1
            time.sleep(1) # required, otherwise uniqid gets mixed up by the server somehow.
        print("Successful commands identified during fuzzing: ")
        for lineNumber in successfulCmds:
            print (lines[lineNumber])
        exit
    thread.start_new_thread(run, ()) #  connection must stay open to be able to send message, but still allow the server to send messages at any time

# even handler for receiving messages from the ws server
def on_message(ws, message):
    mes = json.loads(message)

    if "uniqid" in mes.keys():
        uniqid = mes["uniqid"]
    if mes["type"] == "connection":
        print("[+] Connected!")
    elif mes["type"] == "dispatcher":
        pass
    elif mes["type"] == "response":
        if(("Forbidden command" in mes["payload"]) == False and len(mes["payload"]) > 0):
            print("Succesful command response: " + mes['payload'])
            print("uniqid (line in wordlist): " + str(mes['uniqid']).strip())
            if (mes["uniqid"] not in successfulCmds): # prevent duplicates
                successfulCmds.append(mes["uniqid"])
    else:
        print(mes)

def on_error(ws, error):
    print(error)

def on_close(ws):
    print("[+] Connection Closed")

def toJson(task,data,uniqid):
    req = {
        "task": task,
        "data": data,
        "uniqid": uniqid, # uniqid gets reflected in the response so it is possible to map request to response
        "key" : key
    }
    return json.dumps(req)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument('--url', '-u',
                        required=True,
                        dest='url',
                        help='Websocket URL')
    parser.add_argument('--key', '-k',
                        required=True,
                        dest='key',
                        help='authenticationToken')
    parser.add_argument('--wordlist', '-w',
                        required=True,
                        dest='wordlist',
                        help='wordlist for fuzzing')
    parser.add_argument('--verbose', '-v',
                        help='Print more data',
                        action='store_true')
    
    args = parser.parse_args()

    key = args.key
    wordlist = args.wordlist
    websocket.enableTrace(args.verbose) # -v for verbose output
   
    ws = websocket.WebSocketApp(args.url,
                              on_message = on_message,
                              on_error = on_error,
                              on_close = on_close,
                              on_open = on_open)

    ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE}) # ignore the self-signed certificate of target
